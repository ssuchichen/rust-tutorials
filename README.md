# Rust Tutorials
Rust入门教程

## 通用知识
### 选择Rust不同版本
```
# 查看当前有哪些版本
rustup toolchain list

# 下载某个版本
rustup toolchain install 1.79

# 设置默认版本
rustup default 1.79
```

### dependencies和dev-dependencies
| 依赖类型                 | 何时编译                                                       | 何时链接          | 何时包含到最终产物 |
|----------------------|------------------------------------------------------------|---------------|-----------|
| `[dependencies]`     | `cargo build` <br/>`cargo test`                            | `cargo build` | ✅ 是的      |
| `[dev-dependencies]` | `cargo test` <br/>`cargo bench` <br/>`cargo run --example` | 仅在测试或基准测试时    | ❌ 否       |


## 重要概念

### Trait
中文翻译为`特征、特性、特质`，类似其他语言的`接口`

### Iterator
迭代器是一种遍历集合（如数组、向量、哈希映射等）中元素的方法。通过使用迭代器，以一种高效且抽象的方式遍历集合中的元素，而不需要关心底层的数据结构。


## Time
* `Duration`：持续时间（一段时间）
* `Instant`：时刻（一个时间点）

### Chrono库
在`Rust`的`chrono`库中，`NaiveDate`、`NaiveTime`和`NaiveDateTime`是用于处理日期和时间的基本类型。它们被称为“朴素的”（`naive`），
因为这些类型不包含时区信息，适用于那些不需要考虑时区的场景。

* `NaiveDate`
  * 含义：表示一个没有时区的日期（即年-月-日）。
  * 用途：当你只需要处理日期本身而不关心具体的时间或时区时使用。例如，生日、节假日等只与日期有关的场景。
* `NaiveTime`
  * 含义：表示一个没有日期和时区的具体时间（即时:分:秒.纳秒）。
  * 用途：适合于仅需要关注时间的情况，如闹钟设置、工作时间等场景。
* `NaiveDateTime`
  * 含义：结合了`NaiveDate`和`NaiveTime`，代表一个没有时区的日期和时间。
  * 用途：当你需要同时记录日期和时间但又不需要考虑时区信息时非常有用。例如，记录某个事件发生的精确时刻（假设时区不影响该事件的记录）。

## Pin和Unpin
在`Rust`中，`Pin`和`Unpin`是与自引用数据结构和异步编程密切相关的概念，主要用于确保内存安全和正确性。

### Pin
* `Pin`是一个类型（`std::pin::Pin`），它“固定”了一个值的内存位置，保证这个值在内存中不会被移动。
* 在`Rust`中，内存安全依赖于值的不可变性或可控的移动性。对于普通类型，移动（如从一个变量赋值到另一个变量）是安全的，但对于某些自引用类型（如包含指向自身某个字段的指针），移动会导致引用失效，破坏内存安全。
* `Pin`提供了一种机制，确保被固定的值不会被意外移动。

### Unpin
* `Unpin`是一个标记`trait`（`marker trait`），表示一个类型在被固定（`pinned`）后仍然可以安全地移动。
* 默认情况下，大多数类型都实现了`Unpin`，因为它们的移动不会引发内存安全问题。只有少数特殊类型（通常是自引用类型或与异步相关的类型）不实现`Unpin`。
* 如果一个类型实现了`Unpin`，那么`Pin`对它的约束实际上不起作用，可以自由移动。


### 为什么需要 Pin 和 Unpin
`Rust`的异步编程（`async/await`）和某些数据结构（如`Future`）可能会生成自引用类型。例如，一个`Future`可能包含一个指针，指向它自己的某个字段。
如果这个`Future`被移动，指针会变成“悬垂指针”（`dangling pointer`），导致未定义行为。
`Pin`和`Unpin`的设计是为了解决这个问题：
* `Pin`确保自引用类型在构造后不会被移动。
* `Unpin`允许普通类型在固定后仍然保持灵活性。


### 应用场景
* 异步编程
  * 在`Rust`中，`Future trait` 的实现可能涉及自引用。例如，使用`async`块生成的`Future`可能包含指向栈上数据的引用。
  * Pin 被用来保证这些 `Future` 在轮询（`poll`）时不会因为移动而失效。
  * 示例：`tokio`或`async-std`中的异步任务通常需要`Pin<&mut Self>`。
* 自引用数据结构
  * 比如一个结构体中包含一个字段的引用，指向它自己的另一个字段。
  * 如果这个结构体被移动，引用会指向错误的内存位置，`Pin`可以防止这种情况。
* 库设计
  * 当你设计一个库，要求某些类型在使用时保持固定时，可以使用`Pin`来强制约束调用者。








